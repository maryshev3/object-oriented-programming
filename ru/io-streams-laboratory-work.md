---
layout: default
title: Лабораторная работа. Модульные программы. Ввод/вывод в C++. Библиотеки ввода/вывода
lang: ru
---

# Лабораторная работа по теме "Модульные программы. Ввод/вывод в C++. Библиотеки ввода/вывода"

## Задание для разбора

Разработайте класс ***BankAccount*** (банковский счёт) с:

- полями:

    - ФИО владельца счёта (целое число);

    - текущий баланс счёта (дробное число).

- методами:

    - внесения денег на счёт;

    - снятия денег со счёта.

Используйте перегрузки операторов ***<<*** и ***>>*** для ввода-вывода объектов через стандартные и файловые потоки. Для организации ввода/вывода данных создайте абстрактный класс и сделайте две реализации:
- одна для работы с консолью;
- другая - для файлов.

При реализации классов используйте разделение на заголовочный файл (*.hpp*) и файл с реализацией (*.cpp*).

## Разбор задания

Начнём с реализации класса BankAccount. Классы, отвечающие за реализацию бизнес логики будем располагать в папке Models. Для этого, создадим её. В дереве с файлами в правой части интерфейса Visual Studio изменим режим отображения файлов, нажав на соответствующую кнопку (Рисунок 1).

![Создание нового репозитория]({{ '/assets/images/io-streams-laboratory-work/1.png' | relative_url }}){: .center-img }
<p style="text-align: center;">Рисунок 1 – Отображение всех файлов</p>

На созданный проект нажмём правой кнопкой мыши, а затем в меню ![Кнопка Add]({{ '/assets/images/io-streams-laboratory-work/1_1.png' | relative_url }}) нажмём на ![Кнопка New Folder]({{ '/assets/images/io-streams-laboratory-work/1_2.png' | relative_url }}). В дереве файлов появится новая папка ![Папка NewFolder1]({{ '/assets/images/io-streams-laboratory-work/1_3.png' | relative_url }}), в которую можем ввести нужное название ![Папка Models]({{ '/assets/images/io-streams-laboratory-work/1_4.png' | relative_url }}).

Для создания класса нажмём на ![Кнопка Class...]({{ '/assets/images/io-streams-laboratory-work/1_5.png' | relative_url }}). В открывшемся окне введём имя для класса, .h (.hpp) и .cpp файлов (Рисунок 2).

![Создание класса]({{ '/assets/images/io-streams-laboratory-work/2.png' | relative_url }}){: .center-img }
<p style="text-align: center;">Рисунок 2 – Создание класса</p>

Сгенерированные файлы перенесём в папку *Models*. Для этого надо выделить два файла, а затем удерживая левую кнопку мыши перетащим в папку (Рисунок 3).

![Сохранение файлов класса в папке]({{ '/assets/images/io-streams-laboratory-work/3.png' | relative_url }}){: .center-img }
<p style="text-align: center;">Рисунок 3 – Сохранение файлов класса в папке</p>

В файле ***BankAccount.h*** опишем интерфейс класса, а именно его поля и методы. В данном файле приводятся только определения методов, а их реализация будет в файле .cpp. Исходя из требований к заданию, определим поля *m_owner_full_name*, *m_current_balance* и методы *cache_in*, *cache_out* (Рисунок 4).

![Объявление полей и методов]({{ '/assets/images/io-streams-laboratory-work/4.png' | relative_url }}){: .center-img }
<p style="text-align: center;">Рисунок 4 – Объявление полей и методов</p>

Помимо этого, можно определить методы для получения текущего баланса, получения и изменения ФИО владельца, а также конструктор без параметров и конструктор, принимающий ФИО владельца, начальный баланс (Рисунок 5).

![Объявление конструкторов и геттеров, сеттеров]({{ '/assets/images/io-streams-laboratory-work/5.png' | relative_url }}){: .center-img }
<p style="text-align: center;">Рисунок 5 – Объявление конструкторов и геттеров, сеттеров</p>

Также переопределим операции ***<<*** и ***>>*** как дружественные функции (Рисунок 6).

![Объявление перегрузки операторов ввода, вывода]({{ '/assets/images/io-streams-laboratory-work/6.png' | relative_url }}){: .center-img }
<p style="text-align: center;">Рисунок 6 – Объявление перегрузки операторов ввода, вывода</p>

Далее реализуем объявленные конструкторы и методы в .cpp файле. Начнём с реализации конструкторов. Для этого необходимо следовать шаблону:

```
<Название класса>::<Название класса>(<Аргументы конструктора>){
    <Реализация конструктора>
}
```

Реализованные конструкторы имеют следующий вид (Рисунок 7):

![Реализация конструкторов]({{ '/assets/images/io-streams-laboratory-work/7.png' | relative_url }}){: .center-img }
<p style="text-align: center;">Рисунок 7 – Реализация конструкторов</p>

Для реализации методов класса необходимо следовать шаблону:

```
<Тип возвращаемого значения> <Название класса>::<Название метода>(<Аргументы метода>){
    <Реализация метода>
}
```

Реализованные GET, SET методы (Рисунок 8):

![Реализация геттеров, сеттеров]({{ '/assets/images/io-streams-laboratory-work/8.png' | relative_url }}){: .center-img }
<p style="text-align: center;">Рисунок 8 – Реализация геттеров, сеттеров</p>

Реализованные основные методы (Рисунок 9):

![Реализация основных методов]({{ '/assets/images/io-streams-laboratory-work/9.png' | relative_url }}){: .center-img }
<p style="text-align: center;">Рисунок 9 – Реализация основных методов</p>

Реализованные перегрузки операций ***<<*** и ***>>*** (т.к. они являются не методами, а внешними функциями, то им не надо указывать через **::** название класса) (Рисунок 10):

![Перегрузка операторов ввода, вывода]({{ '/assets/images/io-streams-laboratory-work/10.png' | relative_url }}){: .center-img }
<p style="text-align: center;">Рисунок 10 – Перегрузка операторов ввода, вывода</p>

Для реализации классов ввода/вывода в консоль или файл создадим папку ***IOServices***, а затем создадим базовый абстрактный класс ***BankAccountIOService***, который содержит методы для ввода или вывода данных в некоторый источник. Действия по созданию аналогичны созданию папки ***Models*** и класса ***BankAccount*** (Рисунок 11).

![Создание сервиса ввода, вывода]({{ '/assets/images/io-streams-laboratory-work/11.png' | relative_url }}){: .center-img }
<p style="text-align: center;">Рисунок 11 – Создание сервиса ввода, вывода</p>

Заголовочный файл ***BankAccountIOService.h*** содержит только объявления методов. Т.к. у него нет никаких реализаций, то файл ***BankAccountIOService.cpp*** останется пустым (Рисунок 12).

![Объявление абстрактного класса]({{ '/assets/images/io-streams-laboratory-work/12.png' | relative_url }}){: .center-img }
<p style="text-align: center;">Рисунок 12 – Объявление абстрактного класса</p>

Напишем класс ***BankAccountIOConsoleService*** для ввода/вывода в консоль. В заголовочном файле укажем базовый класс и намерение перегрузить виртуальные методы (Рисунок 13).

![Объявление реализации абстрактного класса (1)]({{ '/assets/images/io-streams-laboratory-work/13.png' | relative_url }}){: .center-img }
<p style="text-align: center;">Рисунок 13 – Объявление реализации абстрактного класса (1)</p>

В файле .cpp уже описываем реализацию методов, соблюдая шаблон реализации методов. Модификатор override при этом уже указывать не требуется (Рисунок 14).

![Реализация абстрактного класса (1)]({{ '/assets/images/io-streams-laboratory-work/14.png' | relative_url }}){: .center-img }
<p style="text-align: center;">Рисунок 14 – Реализация абстрактного класса (1)</p>

Аналогичным образом реализуем класс ***BankAccountIOFileService*** для ввода/вывода в файл. Помимо методов базового класса определим также конструктор для того, чтобы можно было изменять папку для сохранения файлов (Рисунок 15).

![Объявление реализации абстрактного класса (2)]({{ '/assets/images/io-streams-laboratory-work/15.png' | relative_url }}){: .center-img }
<p style="text-align: center;">Рисунок 15 – Объявление реализации абстрактного класса (2)</p>

Конструктор и метод заполнения имеют следующую реализацию (Рисунок 16):

![Реализация абстрактного класса (2)]({{ '/assets/images/io-streams-laboratory-work/16.png' | relative_url }}){: .center-img }
<p style="text-align: center;">Рисунок 16 – Реализация абстрактного класса (2)</p>

Метод сохранения объекта в файл (Рисунок 17):

![Реализация метода сохранения объекта в файл]({{ '/assets/images/io-streams-laboratory-work/17.png' | relative_url }}){: .center-img }
<p style="text-align: center;">Рисунок 17 – Реализация метода сохранения объекта в файл</p>

Последним шагом необходимо написать код основной функции ***main***. Определять способ заполнения и вывода объекта можно на основе пользовательского ввода (Рисунок 18).

![Реализация функции main]({{ '/assets/images/io-streams-laboratory-work/18.png' | relative_url }}){: .center-img }
<p style="text-align: center;">Рисунок 18 – Реализация функции main</p>

Полный текст программы приведён GitHub по ссылке: https://github.com/maryshev3/BankAccountApplication/tree/main

## Задание для самостоятельного решения

Разработайте класс InventoryItem для управления складскими запасами определённого товара с:

- полями:

    - код товара (строка);

    - описание товара (строка);

    - количество товара на складе (целое число);

    - цена за единицу товара в рублях (дробное число).

- методами:

    - увеличения количества товара на складе;

    - списания определённого количества товара на складе;

    - подсчёта общей цены товара на складе.

Используйте перегрузки операторов ***<<*** и ***>>*** для ввода-вывода объектов через стандартные и файловые потоки. Для организации ввода/вывода данных создайте абстрактный класс и сделайте две реализации:

- одна для работы с консолью

- другая - для файлов.