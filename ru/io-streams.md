---
layout: default
title: Модульные программы. Ввод/вывод в C++. Библиотеки ввода/вывода
lang: ru
---

# Модульные программы. Ввод/вывод в C++. Библиотеки ввода/вывода

## Модули в C++

**Модули** — это логически связанный набор исходных (.cpp) и заголовочных (.hpp) файлов, в котором заголовочные файлы содержат объявления (интерфейс) классов, функций, констант и других сущностей, а исходные файлы содержат их реализации (определения). Такой модуль служит единицей организации кода, позволяя разделять программу на независимые части, которые компилируются отдельно и используются совместно через интерфейс (объявления функций, методов), представленный заголовочными файлами.

Наиболее удобно использовать разделение на .cpp и .hpp файлы при разработке классов. Например, реализация класса Account с разделением выглядит следующим образом:

*Account.hpp*
```cpp
#include <string>

class Account {
private:
    std::string owner;
    double balance;

public:
    Account(const std::string& ownerName, double initialBalance);
    void deposit(double amount);
    void withdraw(double amount);
    void displayBalance();
};
```

*Account.cpp*
```cpp
#include "Account.hpp"
#include <iostream>

Account::Account(const std::string& ownerName, double initialBalance) {
    owner = ownerName;
    balance = initialBalance;
}

void Account::deposit(double amount) {
    balance += amount;
}

void Account::withdraw(double amount) {
    if (amount <= balance) {
        balance -= amount;
    }
}

void Account::displayBalance() {
    std::cout << owner << "'s account balance: " << balance << "\n";
}
```

Таким образом, в файле *Account.hpp* объявляется класс, все его поля и методы, а в *Account.cpp* пишется их реализация.

Для того, чтобы в *.cpp* файле написать реализацию для метода, перед его названием необходимо написать ***“<имя класса>::”***.

Этот подход к созданию классов имеет несколько преимуществ:

- при анализе назначения класса достаточно посмотреть только заголовочный (*.hpp*) файл, т.к. по названиям методов уже будет понятна его суть;

- при написании кода можно временно абстрагироваться от конкретных реализаций: в заголовочном (*.hpp*) файле можно написать определение класса и затем использовать его в других модулях, а реализацию написать позже.

Для того, чтобы использовать разработанный класс, его необходимо подключить директивой include.

*main.cpp*
```cpp
#include "Account.hpp"

int main() {
    Account acc("Alice", 1000);
    acc.deposit(500);
    acc.withdraw(200);
    acc.displayBalance();
    return 0;
}
```

При подключении модулей через директиву include может возникнуть ситуация, что один и тот же файл подключается много раз. В этом случае возникнет ошибка при компиляции. Для того, чтобы её избежать, стоит использовать директиву #pragma once. При её использовании каждый модуль подключается только один раз.

При отсутствии модульной структуры программы могут возникнуть следующие проблемы:

- дублирование кода: одни и те же функции, классы или переменные повторяются в разных частях программы, так как отсутствует централизованное объявление и реализация;

- слабая читаемость и сложность сопровождения: большой файл с кодом сложнее анализировать, править или передавать для работы другим программистам;

- длительная компиляция: изменение любой части требует перекомпиляции всего проекта, замедляя разработку;

- проблемы с повторным использованием: сложно извлечь или переиспользовать отдельные части программы в другом проекте без явной структуризации.

## Стандартные потоки ввода-вывода

В языке C++ для ввода/вывода данных реализованы специальные классы-потоки: ***istream*** и ***ostream***. В стандартной библиотеке заранее созданы объекты этих классов: ***cin***, ***cout***, ***clog***, ***cerr***.

| **Класс-поток** | **Имя объекта** | **Назначение** |
| --- | --- | --- |
| istream | cin | Используется для ввода данных |
| ostream | cout | Используется для (буферизированного) вывода информации |
| ostream | clog | Используется для (буферизированного) вывода служебной информации |
| ostream | cerr | Используется для (небуферизированного) вывода ошибок во время выполнения программы |

<div class="task-box">
  <p><strong>Буферизация</strong> — важная особенность потоков ввода-вывода. Поток cout и clog буферезированы. Это означает, что данные сначала накапливаются в памяти, а потом выводятся сразу группой. Это снижает количество обращений к устройству вывода и повышает производительность.</p>

  <p>Поток cerr при этом не буферизирован, так как ошибки должны быть показаны максимально быстро для оперативного реагирования.</p>
</div>

Для использования поток необходимо подключить директивой include соответствующий либо один из классов *ostream*/*istream*, либо сразу оба, прописав *#include \<iostream\>*.

Ниже представлен пример использования стандартных потоков ввода/вывода:

*Использование объектов ввода/вывода*
```cpp
#include <iostream>

int main() {
    int a, b;

    // Ввод переменных a, b при помощи cin.
    std::cin >> a;
    std::cin >> b;

    // Вывод служебной информации о том, что начинается процесс деления чисел.
    std::clog << "Отладка программы. Начинается процесс деления числа a на b.\n";

    if (b == 0) {
        std::cerr << "Ошибка деления. Делитель оказался равен 0. Деление не может быть выполнено.\n";
    } else {
        double division_result = (double)a / b;
        
        std::cout << "Результат деления числа a на b равен: " << division_result << "\n";
    }

    return 0;
}
```

Стоит понимать, что не каждую переменную/объект можно ввести/вывести, используя потоки ввода/вывода. Эти операторы поддерживаются для большинства встроенных типов (int, double, float, …), но по-умолчанию их нельзя использовать для пользовательских типов. Далее будет описано, как реализовать поддержку использования объектов собственных классов в потоках cin, cout, clog, cerr.

При использовании буферизированных потоков может возникнуть необходимость вывести сообщение сразу. Для этого необходимо сбросить текущий буфер. Для этого могут использоваться операторы endl или flush. Оба оператора сбрасывают кеш и вызываются при использовании потоков вывода. Отличие заключается в том, что при использовании endl вывод следующих сообщений будет производиться со следующей строки, а flush не сделает переноса строки.

*Использование операторов сброса буфера вывода*
```cpp
#include <iostream>

int main() {
    std::cout << "Всем привет," << std::endl;

    std::cout << "Желаю хорошего дня" << std::flush;
    std::cout << " и прекрасного настроения!" << std::endl;

    // В консоль будет выведено сообщение:
    // Всем привет,
    // Желаю хорошего дня и прекрасного настроения!

    return 0;
}
```

При использовании объектов ввода/вывода необходимо указывать их пространство имён: std. Однако, это может быть неудобно при многократном вводе/выводе данных. Чтобы не указывать явно пространство имён, его можно подключить заранее командой using namespace std;

*Подключение пространства имён std*
```cpp
#include <iostream>

using namespace std;

int main() {
    cout << "Всем привет," << endl;

    cout << "Желаю хорошего дня" << flush;
    cout << " и прекрасного настроения!" << endl;

    // В консоль будет выведено сообщение:
    // Всем привет,
    // Желаю хорошего дня и прекрасного настроения!

    return 0;
}
```

